#######################################################
# BDSA Lab
#
# Homework 06 - PasswordCracker implementation in Presto 
#######################################################

In this assignment, you will implement PasswordCracker in Presto, a SQL Engine running on Hadoop ecosystem.   
(For more information about Presto, refer to https://prestodb.io/)

***********
1. Overview
***********

To learn about Presto, please read developer guide[1] in the official website of Presto. It covers the basic structure of Presto and its plugin system.

[1]: https://prestodb.io/docs/current/develop.html Developer Guide -- you need to understand the concepts of Plugin, Connector, and Functions to understand this assignment.

In Presto, plugins are loaded dynamically at runtime. Plugin information is specified in presto-main/etc/config.properties file, in "plugin.bundles" parameter, as following:

    In ${presto-workingDirectory}/presto-main/etc/config.properties  
        +----------------------------------------------------------------------+
        |    Some configurations here ...                                      |     
        |    .                                                                 |     
        |    .                                                                 |
        |    plugin.bundles=presto-mysql/pom.xml \                             |                             
        |                   presto-tpch/pom.xml                                |         
        +----------------------------------------------------------------------+

To understand the structure of pom.xml files, see [2]
[2]: https://maven.apache.org/guides/introduction/introduction-to-the-pom.html

Presto loads catalog information (list of databases/connectors, etc) at runtime, reading properties files in etc/catalog/ (*.properties)

    Example catalog files
         ${presto-workingDirectory}/presto-main/etc/catalog/mysql.properties.
         ${presto-workingDirectory}/presto-main/etc/catalog/hive.properties.
         ${presto-workingDirectory}/presto-main/etc/catalog/redis.properties.
         ${presto-workingDirectory}/presto-main/etc/catalog/cracker.properties. // our own catalog.

When you start Presto server, it reads plugin information from presto-main/etc/config.properties and loads the plugins.
Then it reads all the files in presto-main/etc/catalog/*.properties and reads catalog information and stores internally.
In our case cracker.properties contains the (simple) necessary information.

In this assignment, we will implement cracker connector (our Password Cracker) which provide a custom SQL function that computes MD5 hash. 

For example, the following query uses the function "encrypt" provided by the cracker catalog to run the select operation.

    SELECT password FROM cracker.md5.candidate WHERE encrypt(password) = 'b94af680733a1075a899a67d86b384a3';

    (Presto refers to a table by [catalog].[schema].[table_name]. e.g. SELECT COLUMN_NAME FROM [catalog].[schema].[table_name] )

The above query fetches the tuples (or strings in this case) from crackr.md5.candidate conceptually storing all possible MD5 hashes,
and select the string whose encrypt value is equivalent to 'b94af680733a1075a899a67d86b384a3'.

The overall process for compiling and running the query is as follows:

    1. After analyzing the query, Presto fetches the needed information, such as table name, schema name, column name, etc, from CrackerMetadata class
       that manages metadata about the catalog (e.g. returns tables given a schema name).
    2. CrackerSplitManager partitions the solution space and creates splits, which is distributed by Presto to to workers for processing.
    3. Using the splits, CrackerRecordSetProvider creates an instance of CrackerRecordSet and creates CrackerRecordCursor.
    4. CrackerRecordCursor (which is supposed to enumerate Records in RecordSet) generates a candidate string, which corresponds to a tuple in a table for Databases.
        1) If advanceNextPosition() returns true, Presto fetches a string using getSlice().
        2) Then, Presto computes the MD5 hash of the string with the encrypt() function in EncryptFunction class.
        3) Presto executes the where clause in the query and compare the encrypted string and 'b94af680733a1075a899a67d86b384a3'
        4) If they are equivalent, the string is added to the result set.

*****************
2. Template Code 
*****************

In ${presto_root_dir}/presto-cracker/ you will see the following classes.
The classes you need to work on are mared with V.
    
    CrackerPlugin class
    CrackerConnectorFactory class
    CrackerMetadata class
    CrackerTableHandle class
    CrackerTableLayoutHandle class
    CrackerColumnHandle class
    CrackerTransactionHandle class
    CrackerHandleResolver class
    CrackerSplit class
    CrackerSplitManager class
    CrackerRecordSetProvider class
    CrackerRecordSet class
V   CrackerRecordCursor class

V   CrackerUtil class
    CrackerConsts class
    EncryptFunction class
    Types class
    

Here are descriptions for some classes. To completely understand how it works, please read the Developer's Guide and our source code.

CrackerPlugin class :

    getConnectorFactories() : a top-level function that Presto calls to retrieve a CrackerConnectorFactory when Presto is ready to create an instance of a connector to back a catalog
    getFunctions() : Return functions to be used by this plugin.
                     Functions which are registred are used as SQL function.

CrackerConnectorFactory class :

    Instances of your connector are created by a ConnectorFactory instance which is created when Presto calls getConnectorFactory() on the plugin. The connector factory is a simple interface responsible for creating an instance of a Connector object that returns instances of the following services:

    ConnectorMetadata
    ConnectorSplitManager
    ConnectorHandleResolver
    ConnectorRecordSetProvider

CrackerMetadata class
CrackerTableHandle class
CrackerTableLayoutHandle class
CrackerColumnHandle class

CrackerSplit class :

    It is similar to CandidateRangeInputSplit in Hadoop (refer to assignment 5) 
    But this class has solution space range(rangeBegin, rangeEnd), not start offset, length and string value which is consist of ranges.
    Each split is passed to the worker node.

CrackerSplitManager class :

    It is similar to CandidateRangeInputFormat in Hadoop (refer to assignment 5)
    It partitions the solution space and creates splits, which is distributed by Presto to to workers for processing.

CrackerRecordSetProvider class
CrackerRecordSet class
CrackerRecordCursor class

    The record set provider creates a record set which in turn creates a record cursor that returns the actual data to Presto. CrackerRecordCursor generates a string(or candidate password) from solution range. a string is passed to Presto via getSlice() method


CrackerUtil class :

    Utility class for computing the encryptedPassword.

EncryptFunction class :

        
*****************
3. What you need to implement 
*****************

In the template code, you will find comments with COMPLETE (all in capital).
You are required to implement the necessary code in those locations.

Here we list all the functions you need to implement:

    1) CrackerRecordCursor class
     - CrackerRecordCursor(...)
     - advanceNextPosition()

    2) CrackerUtil class

For bonus points, you need to implement early termination. Currently, Presto continues running the query 
even after it finds the password. For early termination, you need to somehow make Presto finish running
the qurey once it finds one password that matches the hash value.


*****************
4. Building the Presto
*****************
Refer to : https://github.com/prestodb/presto
But presto files should download at the blackboard

Requirements

    Mac OS X or Linux
    Java 8 Update 92 or higher (8u92+), 64-bit
    Maven 3.3.9+ (for building)
    Python 2.4+ (for running with the launcher script)

If you're window user, maybe you may install the linux in the virtual machine (e.g VirtualBox, VMWare etc.)

    Main Class: com.facebook.presto.server.PrestoServer
    VM Options: -ea -XX:+UseG1GC -XX:G1HeapRegionSize=32M -XX:+UseGCOverheadLimit -XX:+ExplicitGCInvokesConcurrent -Xmx2G -Dconfig=presto-main/etc/config.properties -Dlog.levels-file=etc/log.properties -Dcatalog.config-dir=presto-main/etc/catalog
    Working directory: $MODULE_DIR$
    Use classpath of module: presto-main


In ${presto-dir}
    1) git init
    2) mvn clean install -DskipTests (you should satisfy the requirements)
    3) See above site how to run. (Maybe you may install the intelliJ)

    After running server,

    4) ${presto-dir}/presto-cli/target/presto-cli-*-executable.jar --server [ip address]:[port]

    refer to : https://prestodb.io/docs/current/installation/cli.html

If you run the local, then ignore the Using SOCKS for HIVE or HDFS part in above site.
And if you use the shared machine, change the port in the config.properties

* After editing the code, you must complie the your module.
    - ${presto-dir}> mvn compile -pl presto-cracker


*********
5. Requirements
*********

- You need to fill in the blanks in the template code.
  (Search the string 'COMPLETE' or 'OPTIONAL'which marks the places where you need to implement your code)

- You must write a report describing your implementation. If you submitted an incomplete implementation, 
  you should describe it in your report. (if you do not report what's missing in your implementation, your assignment will be given 0 score).
  The report need to be in word format or pdf format.

- You must name your submission file as following:

    hw6_studentNumber.tar.gz, hw6_studentNumber.pdf (or .docx)

    and submit both files (hw6_studentNumber.tar.gz, hw4_studentNumber.pdf)

    when you make a tar.gz, you should use the 'tar.sh' in ${hw-dir} : 

        bash tar.gz ${STUDEND_ID}
        Usage Example :
            bash tar.gz 20170000

- You must fully describe the code you have implemented.


*********
6. Report
*********

You must submit the report for this assignment as well as your source code.

The report must be in PDF/Word format and include the following :

- Describe the code you have implemented.
  If you have implemented the early termination functionality, describe it in detail.

- If you're not complete some funtions, describe it in you report (if you do not report what is missing in you implementation, your assignment will be given 0 score).

If you have any questions, Please send an email to bongki@unist.ac.kr

